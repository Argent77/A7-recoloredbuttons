/*
 * Updates all PVRZ indices in the BAM v2 file. More formally, this function replaces each valid index 
 * with the the result of (currentIndex - sourceBaseIndex + targetBaseIndex).
 * Note: It is strongly recommended to apply this function only to BAM files with references 
 *       to a contiguous block of PVRZ indices.
 * INT_VAR sourceBaseIndex: The source index base in range [0..99999]. Not required if autoUpdate != 0.
 * INT_VAR targetBaseIndex: The target index base in range [0..99999]. Not required if autoUpdate != 0.
 * INT_VAR autoUpdate:      When set to a non-zero value, the function attempts to automatically 
 *                          find a block big enough to fit each available index into.
 *                          In this case you don't have to specify any of the xxxBaseIndex parameters.
 *                          Default: 1
 * RET originalBaseIndex:   Returns the original base index used by the BAM. Returns -1 on error.
 * RET newBaseIndex:        Returns the new base index used by the BAM. Returns -1 on error.
 */
DEFINE_PATCH_FUNCTION ~A7#BAM_UPDATE_PVRZ_INDICES~
  INT_VAR
    autoUpdate = 1
    // sourceBaseIndex
    // targetBaseIndex
  RET
    originalBaseIndex
    newBaseIndex
BEGIN
  SET originalBaseIndex = "-1"
  SET newBaseIndex = "-1"
  PATCH_IF (ENGINE_IS ~bgee bg2ee eet iwdee~) BEGIN
    PATCH_IF (autoUpdate != 0 || ((VARIABLE_IS_SET sourceBaseIndex) && (VARIABLE_IS_SET targetBaseIndex))) BEGIN
      READ_ASCII 0x00 header_id ( 8 )
      READ_LONG 0x08 header_frames
      READ_LONG 0x0c header_cycles
      READ_LONG 0x10 header_blocks
      READ_LONG 0x14 header_ofs_frames
      READ_LONG 0x18 header_ofs_cycles
      READ_LONG 0x1c header_ofs_blocks
      PATCH_IF (~BAM V2  ~ STRING_EQUAL ~%header_id%~ && header_frames > 0 && header_cycles > 0 && header_blocks > 0 &&
                header_ofs_frames >= 0x20 && header_ofs_cycles >= 0x20 && header_ofs_blocks >= 0x20) BEGIN
        // getting min and max pvrz indices
        PATCH_IF (autoUpdate != 0) BEGIN
          // getting pvrz index range
          SET PVRZ_MIN_IDX = 100000
          SET PVRZ_MAX_IDX = "-1"
          FOR (curBlock = 0; curBlock < header_blocks; curBlock += 1) BEGIN
            READ_SLONG (header_ofs_blocks + 0x1c*curBlock) pvrz_page
            PATCH_IF (pvrz_page >= 0 && pvrz_page <= 99999) BEGIN
              PATCH_IF (pvrz_page < PVRZ_MIN_IDX) BEGIN PVRZ_MIN_IDX = pvrz_page END
              PATCH_IF (pvrz_page > PVRZ_MAX_IDX) BEGIN PVRZ_MAX_IDX = pvrz_page END
            END ELSE BEGIN
              PATCH_WARN ~Invalid PVRZ index found: %pvrz_page%.~
            END
          END

          // determining next block of free PVRZ indices
          PATCH_IF (PVRZ_MIN_IDX <= PVRZ_MAX_IDX) BEGIN
            SET numIndices = PVRZ_MAX_IDX - PVRZ_MIN_IDX + 1
            LPF ~A7#__FIND_FREE_PVRZ_INDEX_P~ INT_VAR numToReserve = numIndices RET freeIndex END
            PATCH_IF (freeIndex >= 0) BEGIN
              SET sourceBaseIndex = PVRZ_MIN_IDX
              SET targetBaseIndex = freeIndex
            END ELSE BEGIN
              PATCH_FAIL ~Unable to find free block of PVRZ indices.~
            END
          END ELSE BEGIN
            PATCH_FAIL ~Unable to parse data blocks.~
          END
        END

        // updating pvrz indices
        PATCH_IF (VARIABLE_IS_SET ~sourceBaseIndex~ && VARIABLE_IS_SET ~targetBaseIndex~) BEGIN
          SET PVRZ_OLD_IDX = 100000
          SET PVRZ_NEW_IDX = 100000
          FOR (curBlock = 0; curBlock < header_blocks; curBlock += 1) BEGIN
            SET curOfs = header_ofs_blocks + 0x1c*curBlock
            READ_SLONG curOfs pvrz_page
            PATCH_IF (pvrz_page >= 0 && pvrz_page <= 99999) BEGIN
              SET new_pvrz_page = pvrz_page - sourceBaseIndex + targetBaseIndex
              PATCH_IF (pvrz_page < PVRZ_OLD_IDX) BEGIN PVRZ_OLD_IDX = pvrz_page END
              PATCH_IF (new_pvrz_page < PVRZ_NEW_IDX) BEGIN PVRZ_NEW_IDX = new_pvrz_page END
              PATCH_IF (sourceBaseIndex != targetBaseIndex) BEGIN
                WRITE_LONG curOfs new_pvrz_page
              END
            END
          END
          PATCH_IF (PVRZ_OLD_IDX < 100000) BEGIN
            SET originalBaseIndex = PVRZ_OLD_IDX
          END
          PATCH_IF (PVRZ_NEW_IDX < 100000) BEGIN
            SET newBaseIndex = PVRZ_NEW_IDX
          END
        END ELSE BEGIN
          PATCH_FAIL ~Required parameters are undefined.~
        END
      END ELSE BEGIN
        PATCH_FAIL ~Invalid or corrupted BAM v2 resource found.~
      END
    END ELSE BEGIN
      PATCH_FAIL ~One or more parameters are undefined.~
    END
  END ELSE BEGIN
    PATCH_WARN ~Game does not support BAM v2 resources. No changes made.~
  END
END


/*
 * Updates all PVRZ indices in the MOS v2 file. More formally, this function replaces each valid index 
 * with the the result of (currentIndex - sourceBaseIndex + targetBaseIndex).
 * Note: It is strongly recommended to apply this function only to MOS files with references 
 *       to a contiguous block of PVRZ indices.
 * INT_VAR sourceBaseIndex: The source index base in range [0..99999].
 * INT_VAR targetBaseIndex: The target index base in range [0..99999].
 * INT_VAR autoUpdate:      When set to a non-zero value, the function attempts to automatically 
 *                          find a block big enough to fit each available index into.
 *                          In this case you don't have to specify any of the xxxBaseIndex parameters.
 *                          Default: 1
 * RET originalBaseIndex:   Returns the original base index used by the MOS. Returns -1 on error.
 * RET newBaseIndex:        Returns the new base index used by the MOS. Returns -1 on error.
 */
DEFINE_PATCH_FUNCTION ~A7#MOS_UPDATE_PVRZ_INDICES~
  INT_VAR
    autoUpdate = 1
    // sourceBaseIndex
    // targetBaseIndex
  RET
    originalBaseIndex
    newBaseIndex
BEGIN
  SET originalBaseIndex = "-1"
  SET newBaseIndex = "-1"
  PATCH_IF (ENGINE_IS ~bgee bg2ee eet iwdee~) BEGIN
    PATCH_IF (autoUpdate != 0 || ((VARIABLE_IS_SET sourceBaseIndex) && (VARIABLE_IS_SET targetBaseIndex))) BEGIN
      READ_ASCII 0x00 header_id ( 8 )
      READ_LONG 0x08 header_width
      READ_LONG 0x0c header_height
      READ_LONG 0x10 header_blocks
      READ_LONG 0x14 header_ofs_blocks
      PATCH_IF (~MOS V2  ~ STRING_EQUAL ~%header_id%~ && header_width > 0 && header_height > 0 && 
                header_blocks > 0 && header_ofs_blocks >= 0x18) BEGIN
        // getting min and max pvrz indices
        PATCH_IF (autoUpdate != 0) BEGIN
          // getting pvrz index range
          SET PVRZ_MIN_IDX = 100000
          SET PVRZ_MAX_IDX = "-1"
          FOR (curBlock = 0; curBlock < header_blocks; curBlock += 1) BEGIN
            READ_SLONG (header_ofs_blocks + 0x1c*curBlock) pvrz_page
            PATCH_IF (pvrz_page >= 0 && pvrz_page <= 99999) BEGIN
              PATCH_IF (pvrz_page < PVRZ_MIN_IDX) BEGIN PVRZ_MIN_IDX = pvrz_page END
              PATCH_IF (pvrz_page > PVRZ_MAX_IDX) BEGIN PVRZ_MAX_IDX = pvrz_page END
            END ELSE BEGIN
              PATCH_WARN ~Invalid PVRZ index found: %pvrz_page%.~
            END
          END

          // determining next block of free PVRZ indices
          PATCH_IF (PVRZ_MIN_IDX <= PVRZ_MAX_IDX) BEGIN
            SET numIndices = PVRZ_MAX_IDX - PVRZ_MIN_IDX + 1
            LPF ~A7#__FIND_FREE_PVRZ_INDEX_P~ INT_VAR numToReserve = numIndices startIndex = PVRZ_MIN_IDX+numIndices RET freeIndex END
            PATCH_IF (freeIndex >= 0) BEGIN
              SET sourceBaseIndex = PVRZ_MIN_IDX
              SET targetBaseIndex = freeIndex
            END ELSE BEGIN
              PATCH_FAIL ~Unable to find free block of PVRZ indices.~
            END
          END ELSE BEGIN
            PATCH_FAIL ~Unable to parse data blocks.~
          END
        END

        // updating pvrz indices
        PATCH_IF (VARIABLE_IS_SET ~sourceBaseIndex~ && VARIABLE_IS_SET ~targetBaseIndex~) BEGIN
          SET PVRZ_OLD_IDX = 100000
          SET PVRZ_NEW_IDX = 100000
          FOR (curBlock = 0; curBlock < header_blocks; curBlock += 1) BEGIN
            SET curOfs = header_ofs_blocks + 0x1c*curBlock
            READ_SLONG curOfs pvrz_page
            PATCH_IF (pvrz_page >= 0 && pvrz_page <= 99999) BEGIN
              SET new_pvrz_page = pvrz_page - sourceBaseIndex + targetBaseIndex
              PATCH_IF (pvrz_page < PVRZ_OLD_IDX) BEGIN PVRZ_OLD_IDX = pvrz_page END
              PATCH_IF (new_pvrz_page < PVRZ_NEW_IDX) BEGIN PVRZ_NEW_IDX = new_pvrz_page END
              PATCH_IF (sourceBaseIndex != targetBaseIndex) BEGIN
                WRITE_LONG curOfs new_pvrz_page
              END
            END
          END
          PATCH_IF (PVRZ_OLD_IDX < 100000) BEGIN
            SET originalBaseIndex = PVRZ_OLD_IDX
          END
          PATCH_IF (PVRZ_NEW_IDX < 100000) BEGIN
            SET newBaseIndex = PVRZ_NEW_IDX
          END
        END ELSE BEGIN
          PATCH_FAIL ~Required parameters are undefined.~
        END

      END ELSE BEGIN
        PATCH_FAIL ~Invalid or corrupted MOS v2 resource found.~
      END
    END ELSE BEGIN
      PATCH_FAIL ~One or more parameters are undefined.~
    END
  END ELSE BEGIN
    PATCH_WARN ~Game does not support MOS v2 resources. No changes made.~
  END
END


/*
 * Copies the specified file into the target folder and updates the pvrz index. More formally, this function replaces 
 * the pvrz index with the result of (currentIndex - originalBaseIndex + newBaseIndex).
 * INT_VAR originalBaseIndex: The current base index (returned by the functions "A7#BAM_UPDATE_PVRZ_INDICES" or 
 *                            "A7#MOS_UPDATE_PVRZ_INDICES" as "originalBaseIndex").
 * INT_VAR newBaseIndex:      The new base index (returned by the functions "A7#BAM_UPDATE_PVRZ_INDICES" or 
 *                            "A7#MOS_UPDATE_PVRZ_INDICES" as "newBaseIndex").
 * STR_VAR sourceFile:        The source file to copy. The filename must match the regular expression "MOS[0-9]{4,5}\.PVRZ" 
 *                            (e.g. MOS0000.PVRZ, mos1592.pvrz or Mos12345.PVRZ). Case is ignored.
 * STR_VAR targetFolder:      The target folder to copy the source file into. Default: "override"
 * Returns all variables that are automatically set by the COPY action.
 *
 * Note: It is recommended to use one of WeiDU's loop structures to copy multiple files.
 *
 * Example for a multi-file copy:
 * ACTION_FOR_EACH file IN ~MOS1000.PVRZ~ ~MOS1001.PVRZ~ ~MOS1002.PVRZ~ BEGIN
 *   LAF ~A7#PVRZ_COPY_UPDATED~
 *     INT_VAR
 *       originalBaseIndex = 1000
 *       newBaseIndex = 1200
 *     STR_VAR
 *       sourceFile = EVAL ~myModFolder/mySubFolder/%file%~
 *   END
 * END
 * Note: You can omit the INT_VAR entries if you called either "A7#BAM_UPDATE_PVRZ_INDICES" or 
 *       "A7#MOS_UPDATE_PVRZ_INDICES" beforehand.
 */
DEFINE_ACTION_FUNCTION ~A7#PVRZ_COPY_UPDATED~
  INT_VAR
    // originalBaseIndex
    // newBaseIndex
  STR_VAR
    // sourceFile
    targetFolder = ~override~
  RET
    SOURCE_DIRECTORY SOURCE_FILESPEC SOURCE_FILE SOURCE_RES SOURCE_EXT SOURCE_SIZE
    DEST_DIRECTORY DEST_FILESPEC DEST_FILE DEST_RES DEST_EXT
BEGIN
  ACTION_IF (VARIABLE_IS_SET ~sourceFile~ && VARIABLE_IS_SET ~originalBaseIndex~ && VARIABLE_IS_SET ~newBaseIndex~) BEGIN
    OUTER_SET strlen = STRING_LENGTH ~%sourceFile%~
    ACTION_IF ((~%sourceFile%~ STRING_CONTAINS_REGEXP ~[Mm][Oo][Ss][0-9][0-9][0-9][0-9][0-9]?\.[Pp][Vv][Rr][Zz]$~) == 0) BEGIN
      <<<<<<<< a7#inlined/src.tmp
      >>>>>>>>
      <<<<<<<< a7#inlined/dst.tmp
      >>>>>>>>
      COPY - ~a7#inlined/src.tmp~ ~a7#inlined/dst.tmp~
        INSERT_BYTES 0x00 strlen
        WRITE_ASCIIE 0x00 ~%sourceFile%~
        digitEx   = (BYTE_AT (strlen - 10))       // extra digit in case of a 5-digits number
        digit1000 = (BYTE_AT (strlen - 9)) - 48
        digit100  = (BYTE_AT (strlen - 8)) - 48
        digit10   = (BYTE_AT (strlen - 7)) - 48
        digit1    = (BYTE_AT (strlen - 6)) - 48

      OUTER_SET digitEx = (digitEx < 48 || digitEx > 57) ? 0 : digitEx - 48

      ACTION_IF (digit1000 >= 0 && digit1000 <= 9 && digit100 >= 0 && digit100 <= 9 && 
                 digit10 >= 0 && digit10 <= 9 && digit1 >= 0 && digit1 <= 9 && 
                 digitEx >= 0 && digitEx <= 9) BEGIN
        OUTER_SET pvrz_page = digitEx*10000 + digit1000*1000 + digit100*100 + digit10*10 + digit1
        ACTION_IF (pvrz_page >= 0 && pvrz_page <= 99999) BEGIN
          OUTER_SET new_pvrz_page = pvrz_page - originalBaseIndex + newBaseIndex
          ACTION_IF (new_pvrz_page >= 0 && new_pvrz_page < 10) BEGIN
            OUTER_TEXT_SPRINT newFile ~%targetFolder%/MOS000%new_pvrz_page%.PVRZ~
          END ELSE ACTION_IF (new_pvrz_page >= 10 && new_pvrz_page < 100) BEGIN
            OUTER_TEXT_SPRINT newFile ~%targetFolder%/MOS00%new_pvrz_page%.PVRZ~
          END ELSE ACTION_IF (new_pvrz_page >= 100 && new_pvrz_page < 1000) BEGIN
            OUTER_TEXT_SPRINT newFile ~%targetFolder%/MOS0%new_pvrz_page%.PVRZ~
          END ELSE BEGIN
            OUTER_TEXT_SPRINT newFile ~%targetFolder%/MOS%new_pvrz_page%.PVRZ~
          END
          COPY ~%sourceFile%~ ~%newFile%~ EVAL
        END
      END ELSE BEGIN
        FAIL ~Source file string does not point to a valid MOSxxxx.PVRZ~
      END
    END ELSE BEGIN
      FAIL ~Source file string does not point to a valid MOSxxxx.PVRZ~
    END
  END ELSE BEGIN
    FAIL ~One or more required parameters are undefined.~
  END
END

/*
 * This action function attempts to find the first available free PVRZ index of a contiguous block 
 * which guarantees to fit at least "NumToReserve" indices.
 * INT_VAR numToReserve: Find a contiguous block of at least this number of free indices (default: 1)
 * INT_VAR startIndex:   Index to start looking for (default: 1000)
 * RET freeIndex:        Returns the first available index matching the specified parameters. Returns -1 otherwise.
 */
DEFINE_ACTION_FUNCTION ~A7#FIND_FREE_PVRZ_INDEX~
  INT_VAR
    numToReserve = 1
    startIndex = 1000
  RET
    freeIndex
BEGIN
  OUTER_SET freeIndex = "-1"
  ACTION_IF (ENGINE_IS ~bgee bg2ee eet iwdee~) BEGIN
    ACTION_IF (numToReserve < 1) BEGIN
      OUTER_SET numToReserve = 1
      WARN ~Block size too small. Using default of 1.~
    END ELSE ACTION_IF (numToReserve > 999) BEGIN
      OUTER_SET numToReserve = 999
      WARN ~Block size too big. Truncating to 999.~
    END
    ACTION_IF (startIndex < 0) BEGIN
      OUTER_SET startIndex = 0
      WARN ~Start index too small. Setting start index to 0.~
    END ELSE ACTION_IF (startIndex+numToReserve > 100000) BEGIN
      OUTER_SET startIndex = 100000 - numToReserve
      WARN ~Start index too big. Setting start index to %startIndex%.~
    END

    OUTER_SET maxIndex = 100000 - numToReserve
    OUTER_SET blockFree = 0
    OUTER_FOR (curIdx = startIndex; curIdx <= maxIndex && blockFree == 0; curIdx += 1) BEGIN
      // checking for free index
      LAF ~A7#__IS_FREE_PVRZ_A~ INT_VAR index = curIdx RET isFreeIndex END

      // checking for free block
      ACTION_IF (isFreeIndex != 0) BEGIN
        OUTER_SET blockFree = 1
        OUTER_FOR (freeIdx = curIdx; freeIdx < curIdx+numToReserve && blockFree != 0; freeIdx += 1) BEGIN
          LAF ~A7#__IS_FREE_PVRZ_A~ INT_VAR index = freeIdx RET isFreeIndex END
          ACTION_IF (isFreeIndex == 0) BEGIN
            OUTER_SET blockFree = 0
          END
        END
      END

      ACTION_IF (blockFree) BEGIN
        OUTER_SET freeIndex = curIdx
      END
    END
  END ELSE BEGIN
    FAIL ~Game does not support PVRZ resources.~
  END
END


// Patch function. Internally used patch version of "A7#FIND_FREE_PVRZ_INDEX".
DEFINE_PATCH_FUNCTION ~A7#__FIND_FREE_PVRZ_INDEX_P~
  INT_VAR
    numToReserve = 1
    startIndex = 1000
  RET
    freeIndex
BEGIN
  SET freeIndex = "-1"
  PATCH_IF (ENGINE_IS ~bgee bg2ee eet iwdee~) BEGIN
    PATCH_IF (numToReserve < 1) BEGIN
      SET numToReserve = 1
      PATCH_WARN ~Block size too small. Using default of 1.~
    END ELSE PATCH_IF (numToReserve > 999) BEGIN
      SET numToReserve = 999
      PATCH_WARN ~Block size too big. Truncating to 999.~
    END
    PATCH_IF (startIndex < 0) BEGIN
      SET startIndex = 0
      PATCH_WARN ~Start index too small. Setting start index to 0.~
    END ELSE PATCH_IF (startIndex+numToReserve > 100000) BEGIN
      SET startIndex = 100000 - numToReserve
      PATCH_WARN ~Start index too big. Setting start index to %startIndex%.~
    END

    SET maxIndex = 100000 - numToReserve
    SET blockFree = 0
    FOR (curIdx = startIndex; curIdx <= maxIndex && blockFree == 0; curIdx += 1) BEGIN
      // checking for free index
      LPF ~A7#__IS_FREE_PVRZ_P~ INT_VAR index = curIdx RET isFreeIndex END

      // checking for free block
      PATCH_IF (isFreeIndex != 0) BEGIN
        SET blockFree = 1
        FOR (freeIdx = curIdx; freeIdx < curIdx+numToReserve && blockFree != 0; freeIdx += 1) BEGIN
          LPF ~A7#__IS_FREE_PVRZ_P~ INT_VAR index = freeIdx RET isFreeIndex END
          PATCH_IF (isFreeIndex == 0) BEGIN
            SET blockFree = 0
          END
        END
      END

      PATCH_IF (blockFree) BEGIN
        SET freeIndex = curIdx
      END
    END
  END ELSE BEGIN
    PATCH_FAIL ~Game does not support PVRZ resources.~
  END
END


// Action function. Internally used to find out if the MOSxxxx.PVRZ does not yet exist. Returns zero if file exists, non-zero otherwise.
DEFINE_ACTION_FUNCTION ~A7#__IS_FREE_PVRZ_A~
  INT_VAR
    // index
  RET
    isFreeIndex
BEGIN
  ACTION_IF (index < 0) BEGIN
    OUTER_SET index = 0
  END ELSE ACTION_IF (index > 99999) BEGIN
    OUTER_SET index = 99999
  END

  ACTION_IF (index >= 0 && index < 10) BEGIN
    OUTER_TEXT_SPRINT curFile ~MOS000%index%.PVRZ~
  END ELSE ACTION_IF (index >= 10 && index < 100) BEGIN
    OUTER_TEXT_SPRINT curFile ~MOS00%index%.PVRZ~
  END ELSE ACTION_IF (index >= 100 && index < 1000) BEGIN
    OUTER_TEXT_SPRINT curFile ~MOS0%index%.PVRZ~
  END ELSE BEGIN
    OUTER_TEXT_SPRINT curFile ~MOS%index%.PVRZ~
  END

  ACTION_IF (FILE_EXISTS_IN_GAME ~%curFile%~) BEGIN
    OUTER_SET isFreeIndex = 0
  END ELSE BEGIN
    OUTER_SET isFreeIndex = 1
  END
END


// Patch function. Internally used to find out if the MOSxxxx.PVRZ does not yet exist. Returns zero if file exists, non-zero otherwise.
DEFINE_PATCH_FUNCTION ~A7#__IS_FREE_PVRZ_P~
  INT_VAR
    // index
  RET
    isFreeIndex
BEGIN
  PATCH_IF (index < 0) BEGIN
    SET index = 0
  END ELSE PATCH_IF (index > 99999) BEGIN
    SET index = 99999
  END

  PATCH_IF (index >= 0 && index < 10) BEGIN
    TEXT_SPRINT curFile ~MOS000%index%.PVRZ~
  END ELSE PATCH_IF (index >= 10 && index < 100) BEGIN
    TEXT_SPRINT curFile ~MOS00%index%.PVRZ~
  END ELSE PATCH_IF (index >= 100 && index < 1000) BEGIN
    TEXT_SPRINT curFile ~MOS0%index%.PVRZ~
  END ELSE BEGIN
    TEXT_SPRINT curFile ~MOS%index%.PVRZ~
  END

  PATCH_IF (FILE_EXISTS_IN_GAME ~%curFile%~) BEGIN
    SET isFreeIndex = 0
  END ELSE BEGIN
    SET isFreeIndex = 1
  END
END


